name: ci

on:
  push:
    branches: [ main ]
  pull_request:
  workflow_dispatch:

permissions:
  contents: read

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  fmt:
    name: rustfmt
    runs-on: ubuntu-latest
    continue-on-error: true
    env:
      # rustup workaround for OverlayFS rename(EXDEV) under Docker/act
      RUSTUP_PERMIT_COPY_RENAME: "1"
      RUSTUP_HOME: /home/runner/.rustup
      CARGO_HOME:  /home/runner/.cargo
    steps:
      # Install stable OUTSIDE the repo so the repo's rust-toolchain.toml ("esp") doesn't apply here
      - uses: dtolnay/rust-toolchain@stable
        with:
          components: rustfmt

      - uses: actions/checkout@v4

      # Run rustfmt explicitly with stable to bypass local override
      - name: Format check (non-blocking)
        run: cargo +stable fmt --all -- --check

  build:
    name: build (${{ matrix.triple }})
    runs-on: ubuntu-latest
    needs: fmt
    strategy:
      matrix:
        include:
          - triple: xtensa-esp32-espidf
            mcu: esp32
          # add more targets if needed, e.g. xtensa-esp32s3-espidf
    env:
      # rustup workaround for OverlayFS rename(EXDEV)
      RUSTUP_PERMIT_COPY_RENAME: "1"
      RUSTUP_HOME: /home/runner/.rustup
      CARGO_HOME:  /home/runner/.cargo
    steps:
      # 0) Get a working cargo/rustup before touching the repo (avoids 'esp' override here)
      - uses: dtolnay/rust-toolchain@stable

      # 1) Bring in the repository (now the repo's rust-toolchain.toml = "esp" is visible)
      - uses: actions/checkout@v4

      # 2) System build dependencies
      - name: Install build dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y ninja-build cmake python3 python3-venv

      # 3) Install espup with STABLE cargo (explicitly sidestep the 'esp' override)
      - name: Install espup
        run: cargo +stable install espup --locked

      # 4) Install the 'esp' toolchain and write an export script for later steps
      - name: Install ESP toolchain (produce export script)
        run: espup install --export-file "$HOME/export-esp.sh"

      # (optional) quick diagnostics
      - name: Show esp toolchain info
        shell: bash
        run: |
          set -euo pipefail
          source "$HOME/export-esp.sh"
          rustup toolchain list
          rustup +esp show

      # 5) Cache cargo & ESP-IDF artifacts
      - name: Cache cargo and ESP-IDF artifacts
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
            ~/.espressif
            .embuild
            target
          key: ${{ runner.os }}-cargo-espressif-${{ matrix.triple }}-${{ hashFiles('**/Cargo.lock', '**/rust-toolchain.toml', '**/.cargo/config.toml') }}
          restore-keys: |
            ${{ runner.os }}-cargo-espressif-${{ matrix.triple }}-

      - name: Put cargo bin on PATH for later steps
        run: echo "$HOME/.cargo/bin" >> "$GITHUB_PATH"

      - name: Install ldproxy (host linker shim)
        run: cargo +stable install ldproxy --locked

      # 6) Build with the esp toolchain explicitly (source export for ESP-IDF env)
      - name: Build (release)
        shell: bash
        env:
          MCU: ${{ matrix.mcu }}
        run: |
          set -euo pipefail
          source "$HOME/export-esp.sh"
          export PATH="$HOME/.cargo/bin:$PATH"   # ensure ldproxy is visible
          cargo +esp build --release --target ${{ matrix.triple }}

      # 7) Install espflash (with esp toolchain) and package firmware
      - name: Install espflash
        shell: bash
        run: |
          set -euo pipefail
          source "$HOME/export-esp.sh"
          cargo +esp install espflash --locked

      - name: Package firmware (.elf and .bin)
        shell: bash
        env:
          MCU: ${{ matrix.mcu }}
        run: |
          set -euo pipefail
          source "$HOME/export-esp.sh"
          export PATH="$HOME/.cargo/bin:$PATH"

          OUTDIR="$GITHUB_WORKSPACE/artifacts"
          CRATE="esp32-soil-sensor"
          ELF="$GITHUB_WORKSPACE/target/${{ matrix.triple }}/release/$CRATE"
          BIN="$OUTDIR/$CRATE.${{ matrix.triple }}.bin"
          ELF_OUT="$OUTDIR/$CRATE.${{ matrix.triple }}.elf"

          mkdir -p "$OUTDIR"
          test -f "$ELF" || { echo "Missing ELF: $ELF"; exit 1; }

          cp "$ELF" "$ELF_OUT"
          # v4.x: <ELF> first, then <IMAGE>
          espflash save-image --chip "$MCU" "$ELF" "$BIN"

          ls -lh "$OUTDIR"

      - name: Upload firmware artifacts
        if: ${{ !env.ACT }}
        uses: actions/upload-artifact@v4
        with:
          name: esp-soil-sensor-${{ matrix.triple }}-${{ github.sha }}
          path: artifacts/*
          if-no-files-found: error
          retention-days: 30

      # Local fallback under `act` (no GitHub token/artifact service)
      - name: Save artifacts locally (act)
        if: ${{ env.ACT }}
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p "$GITHUB_WORKSPACE/_act_artifacts"
          tar -C artifacts -czf "$GITHUB_WORKSPACE/_act_artifacts/${{ matrix.triple }}.tar.gz" .
          echo "Local artifact: $GITHUB_WORKSPACE/_act_artifacts/${{ matrix.triple }}.tar.gz"
          ls -lh "$GITHUB_WORKSPACE/_act_artifacts"
